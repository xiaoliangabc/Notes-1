## [链接](http://blog.csdn.net/poem_qianmo/article/details/25560901)

### 一般步骤
- 1）滤波：边缘检测的算法主要是基于图像强度的一阶和二阶导数，但导数通常对噪声很敏感，因此必须采用滤波器来改善与噪声有关的边缘检测器的性能。常见的滤波方法主要有高斯滤波，即采用离散化的高斯函数产生一组归一化的高斯核（具体见“高斯滤波原理及其编程离散化实现方法”一文），然后基于高斯核函数对图像灰度矩阵的每一点进行加权求和（具体程序实现见下文）。
- 2）增强：增强边缘的基础是确定图像各点邻域强度的变化值。增强算法可以将图像灰度点邻域强度值有显著变化的点凸显出来。在具体编程实现时，可通过计算梯度幅值来确定。
- 3）检测：经过增强的图像，往往邻域中有很多点的梯度值比较大，而在特定的应用中，这些点并不是我们要找的边缘点，所以应该采用某种方法来对这些点进行取舍。实际工程中，常用的方法是通过阈值化方法来检测。


### canny算子

void Canny(InputArray image,OutputArray edges, double threshold1, double threshold2, int apertureSize=3,bool L2gradient=false )

- 第一个参数，InputArray类型的image，输入图像，即源图像，填Mat类的对象即可，且需为单通道8位图像。
- 第二个参数，OutputArray类型的edges，输出的边缘图，需要和源图片有一样的尺寸和类型。
- 第三个参数，double类型的threshold1，第一个滞后性阈值。
- 第四个参数，double类型的threshold2，第二个滞后性阈值。
- 第五个参数，int类型的apertureSize，表示应用Sobel算子的孔径大小，其有默认值3。
- 第六个参数，bool类型的L2gradient，一个计算图像梯度幅值的标识，有默认值false。

### sobel算子

void Sobel (  
InputArray src,//输入图  
 OutputArray dst,//输出图  
 int ddepth,//输出图像的深度  
 int dx,  
 int dy,  
 int ksize=3,  
 double scale=1,  
 double delta=0,  
 int borderType=BORDER_DEFAULT );

- 第一个参数，InputArray 类型的src，为输入图像，填Mat类型即可。
- 第二个参数，OutputArray类型的dst，即目标图像，函数的输出参数，需要和源图片有一样的尺寸和类型。
- 第三个参数，int类型的ddepth，输出图像的深度，支持如下src.depth()和ddepth的组合：
 * 若src.depth() = CV_8U, 取ddepth =-1/CV_16S/CV_32F/CV_64F
 * 若src.depth() = CV_16U/CV_16S, 取ddepth =-1/CV_32F/CV_64F
 * 若src.depth() = CV_32F, 取ddepth =-1/CV_32F/CV_64F
 * 若src.depth() = CV_64F, 取ddepth = -1/CV_64F
- 第四个参数，int类型dx，x 方向上的差分阶数。
- 第五个参数，int类型dy，y方向上的差分阶数。
- 第六个参数，int类型ksize，有默认值3，表示Sobel核的大小;必须取1，3，5或7。
- 第七个参数，double类型的scale，计算导数值时可选的缩放因子，默认值是1，表示默认情况下是没有应用缩放的。我们可以在文档中查阅getDerivKernels的相关介绍，来得到这个参数的更多信息。
- 第八个参数，double类型的delta，表示在结果存入目标图（第二个参数dst）之前可选的delta值，有默认值0。
- 第九个参数， int类型的borderType，我们的老朋友了（万年是最后一个参数），边界模式，默认值为BORDER_DEFAULT。这个参数可以在官方文档中borderInterpolate处得到更详细的信息。

### Laplace算子

void Laplacian(InputArray src,OutputArray dst, int ddepth, int ksize=1, double scale=1, double delta=0, intborderType=BORDER_DEFAULT );

- 第一个参数，InputArray类型的image，输入图像，即源图像，填Mat类的对象即可，且需为单通道8位图像。
- 第二个参数，OutputArray类型的edges，输出的边缘图，需要和源图片有一样的尺寸和通道数。
- 第三个参数，int类型的ddept，目标图像的深度。
- 第四个参数，int类型的ksize，用于计算二阶导数的滤波器的孔径尺寸，大小必须为正奇数，且有默认值1。
- 第五个参数，double类型的scale，计算拉普拉斯值的时候可选的比例因子，有默认值1。
- 第六个参数，double类型的delta，表示在结果存入目标图（第二个参数dst）之前可选的delta值，有默认值0。
- 第七个参数， int类型的borderType，边界模式，默认值为BORDER_DEFAULT。这个参数可以在官方文档中borderInterpolate()处得到更详细的信息。

### scharr滤波器

void Scharr(
InputArray src, //源图
 OutputArray dst, //目标图
 int ddepth,//图像深度
 int dx,// x方向上的差分阶数
 int dy,//y方向上的差分阶数
 double scale=1,//缩放因子
 double delta=0,// delta值
 intborderType=BORDER_DEFAULT )// 边界模式

- 第一个参数，InputArray 类型的src，为输入图像，填Mat类型即可。
- 第二个参数，OutputArray类型的dst，即目标图像，函数的输出参数，需要和源图片有一样的尺寸和类型。
- 第三个参数，int类型的ddepth，输出图像的深度，支持如下src.depth()和ddepth的组合：
 - 若src.depth() = CV_8U, 取ddepth =-1/CV_16S/CV_32F/CV_64F
 - 若src.depth() = CV_16U/CV_16S, 取ddepth =-1/CV_32F/CV_64F
 - 若src.depth() = CV_32F, 取ddepth =-1/CV_32F/CV_64F
 - 若src.depth() = CV_64F, 取ddepth = -1/CV_64F
 - 第四个参数，int类型dx，x方向上的差分阶数。
- 第五个参数，int类型dy，y方向上的差分阶数。
- 第六个参数，double类型的scale，计算导数值时可选的缩放因子，默认值是1，表示默认情况下是没有应用缩放的。我们可以在文档中查阅getDerivKernels的相关介绍，来得到这个参数的更多信息。
- 第七个参数，double类型的delta，表示在结果存入目标图（第二个参数dst）之前可选的delta值，有默认值0。
- 第八个参数， int类型的borderType，我们的老朋友了（万年是最后一个参数），边界模式，默认值为BORDER_DEFAULT。这个参数可以在官方文档中borderInterpolate处得到更详细的信息。
