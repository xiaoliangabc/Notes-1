参考：http://blog.csdn.net/ruglcc/article/details/7814546/

首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）



在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error）



Makefile的规则
target... : prerequisites ...
command
...
...
target也就是一个目标文件，可以是Object File，也可以是执行文件，还可以是一个标签（Label）
prerequisites就是，要生成那个target所需要的文件或是目标。
command也就是make需要执行的命令。（任意的Shell命令）
prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行


Here comes an example
   edit : main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o
           cc -o edit main.o kbd.o command.o display.o \
                      insert.o search.o files.o utils.o
   main.o : main.c defs.h
           cc -c main.c
   kbd.o : kbd.c defs.h command.h
           cc -c kbd.c
   command.o : command.c defs.h command.h
           cc -c command.c
   display.o : display.c defs.h buffer.h
           cc -c display.c
   insert.o : insert.c defs.h buffer.h
           cc -c insert.c
   search.o : search.c defs.h buffer.h
           cc -c search.c
   files.o : files.c defs.h buffer.h command.h
           cc -c files.c
   utils.o : utils.c defs.h
           cc -c utils.c
   clean :
           rm edit main.o kbd.o command.o display.o \
              insert.o search.o files.o utils.o
 在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。
在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要！！！！！！以一个Tab键作为开头！！！！！！！！
make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令
要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份

工作流程：
make会在当前目录下找名字叫“Makefile”或“makefile”的文件。
如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。
如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。
如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）
当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件声明make的终极任务，也就是执行文件edit了。


为了makefile的易维护，在makefile中我们可以使用变量，类似于C语言中的宏
在makefile一开始就这样定义：
objects = main.o kbd.o command.o display.o \
     insert.o search.o files.o utils.o

改良版makefile就变成下面这个样子：
   objects = main.o kbd.o command.o display.o \
             insert.osearch.o files.o utils.o 
   edit : $(objects)
           cc -o edit $(objects)
   main.o : main.c defs.h
           cc -c main.c
   kbd.o : kbd.c defs.h command.h
           cc -c kbd.c
   command.o : command.c defs.h command.h
           cc -c command.c
   display.o : display.c defs.h buffer.h
           cc -c display.c
   insert.o : insert.c defs.h buffer.h
           cc -c insert.c
   search.o : search.c defs.h buffer.h
           cc -c search.c
   files.o : files.c defs.h buffer.h command.h
           cc -c files.c
   utils.o : utils.c defs.h
           cc -c utils.c
   clean :
           rm edit $(objects)
于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。




GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，并且 cc -c whatever.c 也会被推导出来。新的makefile又出炉了。
   objects = main.o kbd.o command.o display.o \
             insert.o search.o files.o utils.o
   edit : $(objects)
           cc -o edit $(objects)
   main.o : defs.h
   kbd.o : defs.h command.h
   command.o : defs.h command.h
   display.o : defs.h buffer.h
   insert.o : defs.h buffer.h
   search.o : defs.h buffer.h
   files.o : defs.h buffer.h command.h
   utils.o : defs.h
   .PHONY : clean
   clean :
           rm edit $(objects)

还可以化简，看看最新风格的makefile。
   objects = main.o kbd.o command.o display.o \
             insert.o search.o files.o utils.o
   edit : $(objects)
           cc -o edit $(objects)
   $(objects) : defs.h
   kbd.o command.o files.o : command.h
   display.o insert.o search.o files.o : buffer.h
   .PHONY : clean
   clean :
           rm edit $(objects)

这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了
.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。







Makefile里有什么：
Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。

        显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。
        隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。
        变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。
        文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。
         注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“\#”。

最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。



引用其它的Makefile：
在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：
include<filename>filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）
有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：
include foo.make *.mk $(bar)
等价于：
include foo.make a.mk b.mk c.mk e.mk f.mk

make命令开始时，会把找寻include所指出的其它Makefile
make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：
1.如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。
2.如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。

如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作，建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。


GNU的make工作时的执行步骤入下：（想来其它的make也是类似）

    1.        读入所有的Makefile。

    2.        读入被include的其它Makefile。

    3.        初始化文件中的变量。

    4.        推导隐晦规则，并分析所有规则。

    5.        为所有的目标文件创建依赖关系链。

    6.        根据依赖关系，决定哪些目标要重新生成。

    7.        执行生成命令。




Makefile书写规则
 规则包含两个部分，一个是依赖关系，一个是生成目标的方法。
Makefile中只应该有一个最终目标，第一条规则中的目标将被确立为最终的目标，如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。

使用通配符
"~"
波浪号（“~”）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen/test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。
"*"
通配符代替了你一系列的文件，如“*.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“*”，那么可以用转义字符“\”，如“\*”来表示真实的“*”字符，而不是任意长度的字符串。

objects = *.o
上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开，不！objects的值就是“*.o”。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：objects := $(wildcard *.o)



文件搜寻
VPATH = src:../headers
上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）

另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：
1.        vpath < pattern> < directories>    为符合模式< pattern>的文件指定搜索目录<directories>。
2.        vpath < pattern>                              清除符合模式< pattern>的文件的搜索目录。
3.        vpath                                                 清除所有已被设置好了的文件搜索目录。
例如：vpath %.h ../headers
“%.h”表示所有以“.h”结尾的文件
可以连续地使用vpath语句，以指定不同搜索策略，表示先在哪找，再在哪找。

伪目标
“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。
伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。
如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：
   all : prog1 prog2 prog3
   .PHONY : all
 
   prog1 : prog1.o utils.o
           cc -o prog1 prog1.o utils.o
   prog2 : prog2.o
           cc -o prog2 prog2.o
   prog3 : prog3.o sort.o utils.o
           cc -o prog3 prog3.o sort.o utils.o

伪目标同样也可成为依赖
   .PHONY: cleanall cleanobj cleandiff
   cleanall : cleanobj cleandiff
           rm program
   cleanobj :
           rm *.o
   cleandiff :
           rm *.diff

静态模式
看一个例子：
   objects = foo.o bar.o
   all: $(objects)
   $(objects): %.o: %.c
   $(CC) -c $(CFLAGS) $< -o $@

上面的规则展开后等价于下面的规则：
   objects = foo.o bar.o
   all: $(objects)
   foo.o : foo.c
           $(CC) -c $(CFLAGS) foo.c -o foo.o
如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了

   bar.o : bar.c
           $(CC) -c $(CFLAGS) bar.c -o bar.o
